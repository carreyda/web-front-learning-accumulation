# JavaScript 事件循环深度解析

## 一、理解浏览器的进程与线程

在深入事件循环之前,我们需要先了解浏览器的底层运行机制。

### 1.1 进程与线程的概念

**进程**是操作系统分配资源的基本单位。可以把进程理解为一个正在运行的程序实例,每个进程都有自己独立的内存空间。就像每个应用程序运行时都需要自己的专属内存空间。

**线程**是进程内的执行单元。一个进程至少有一个线程(主线程),多个线程共享同一个进程的内存空间。形象地说:进程像一个工厂,线程就是工厂里的工人,共享工厂的资源。

### 1.2 浏览器的多进程架构

现代浏览器(如 Chrome)采用多进程架构,将不同功能模块拆分到独立进程中运行,避免相互影响和连环崩溃。

**主要进程包括:**

- **浏览器进程**: 负责界面显示、用户交互、子进程管理
- **网络进程**: 负责加载网络资源
- **渲染进程**: 负责页面渲染,默认为每个标签页开启独立进程
- **GPU 进程**: 处理 3D CSS、Canvas 绘制

![浏览器进程示意图](https://img2024.cnblogs.com/blog/2332774/202507/2332774-20250713131644171-248647450.png)

> 💡 你可以在浏览器的任务管理器中查看当前所有进程

![浏览器任务管理器](https://img2024.cnblogs.com/blog/2332774/202507/2332774-20250713132142676-1821843954.png)

### 1.3 渲染进程中的关键线程

每个标签页的渲染进程内部包含多个线程协同工作:

- **JS 引擎线程(主线程)**: 执行 JavaScript 代码
- **GUI 渲染线程**: 解析 HTML/CSS,构建 DOM 树,页面绘制
- **事件触发线程**: 管理事件队列(点击、定时器等)
- **定时器线程**: 处理 setTimeout、setInterval
- **异步 HTTP 请求线程**: 处理 XMLHttpRequest、fetch

**⚠️ 重要特性**: JS 引擎线程和 GUI 渲染线程是互斥的。JS 执行时会阻塞页面渲染,这就是为什么长时间运行的 JS 会导致页面卡顿。

---

## 二、渲染主线程的工作方式

### 2.1 渲染主线程的职责

渲染主线程是浏览器中最繁忙的线程,需要处理的任务包括:

- 解析 HTML,构建 DOM 树
- 解析 CSS,构建 CSSOM 树
- 计算样式与布局
- 每秒绘制页面 60 次
- 执行全局 JS 代码
- 执行事件处理函数
- 执行计时器回调函数
- ...

### 2.2 任务调度的挑战

面对如此多的任务,渲染主线程遇到了前所未有的调度难题：如何调度任务？

- 正在执行 JS 函数时,用户点击了按钮,该立即处理点击事件吗?
- 正在执行 JS 函数时,计时器到时间了,该立即执行回调吗?
- 同时收到"用户点击"和"计时器到时"两个通知,应该处理哪一个?

### 2.3 排队机制:事件循环的核心

渲染主线程想出了一个绝妙的主意来处理这个问题：**排队**

**工作流程:**

1. 渲染主线程进入一个无限循环
2. 每次循环检查消息队列中是否有任务
3. 如果有任务,取出第一个执行,执行完进入下一次循环
4. 如果没有任务,进入休眠状态
5. 其他线程可随时向消息队列添加任务,新任务加到队列末尾
6. 添加任务时如果主线程休眠,则将其唤醒

**这个持续运行的循环机制,就是「事件循环(Event Loop)」**。

![事件循环工作流程](https://img2024.cnblogs.com/blog/2332774/202508/2332774-20250826000554831-676283681.png)

---

## 三、异步编程的本质

### 3.1 为什么需要异步?

**单线程是异步产生的原因,事件循环是异步的实现方式。**

代码执行过程中会遇到无法立即处理的任务:

- 计时器: `setTimeout`、`setInterval`
- 网络通信: `XMLHttpRequest`、`Fetch`
- 用户操作: `addEventListener`

如果让渲染主线程等待这些任务完成,会导致主线程长期阻塞,浏览器"卡死"。

**渲染主线程承担着极其重要的工作,无论如何都不能阻塞!**

### 3.2 异步的工作方式

浏览器采用异步机制解决阻塞问题:

1. 当遇到异步任务时,主线程将任务委托给其他线程处理
2. 主线程立即结束当前任务,继续执行后续代码
3. 其他线程完成工作后,将回调函数包装成任务
4. 将任务添加到消息队列末尾排队
5. 等待主线程调度执行

**采用异步模式后,浏览器主线程永不阻塞,保证了流畅运行。**

![异步处理机制](https://img2024.cnblogs.com/blog/2332774/202509/2332774-20250914235107252-1916800685.png)

### 3.3 为什么 JS 会阻塞页面渲染?

来看一个例子:

```html
<h1>Mr.Yuan is awesome!</h1>
<button>change</button>
<script>
  var h1 = document.querySelector("h1");
  var btn = document.querySelector("button");

  function delay(duration) {
    var start = Date.now();
    while (Date.now() - start < duration) {}
  }

  btn.onclick = function () {
    h1.textContent = "袁老师很帅!";
    delay(3000); // 死循环 3 秒
  };
</script>
```

**为什么不是先改变文本内容,再执行死循环呢?**

因为 JS 执行和页面渲染都在渲染主线程上,任务执行顺序是:

```
点击事件任务 → 执行 JS 代码(修改 DOM + 死循环) → 渲染页面
```

**JS 执行期间会阻塞渲染,必须等 JS 执行完毕才能更新页面。**

![JS阻塞渲染示意图](https://img2024.cnblogs.com/blog/2332774/202509/2332774-20250914235638567-823868134.png)

---

## 四、任务队列与优先级

### 4.1 消息队列有优先级

虽然单个队列中的任务按先进先出执行,但**不同的消息队列有不同的优先级**。

根据 W3C 最新规范:

- 每个任务都有一个类型,同类型任务必须在一个队列
- 不同类型任务可以分属于不同队列
- 浏览器可根据实际情况从不同队列中取任务
- **浏览器必须有一个微队列,微队列任务优先于所有其他任务**

> https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpo-int

### 4.2 Chrome 中的队列类型

目前 Chrome 至少包含以下队列:

| 队列类型     | 用途                         | 优先级 |
| ------------ | ---------------------------- | ------ |
| **微队列**   | Promise、MutationObserver    | 最高   |
| **交互队列** | 用户操作事件(点击、输入等)   | 高     |
| **延时队列** | setTimeout、setInterval 回调 | 中     |

**执行顺序**: 微队列 > 交互队列 > 延时队列

![任务队列优先级](https://img2024.cnblogs.com/blog/2332774/202511/2332774-20251104234526207-33293948.png)

### 4.3 如何添加微任务

添加任务到微队列的主要方式:

```js
// 使用 Promise
Promise.resolve().then(函数);

// 使用 MutationObserver
const observer = new MutationObserver(函数);
```

---

## 五、事件循环的完整流程

### 5.1 标准执行流程

```
1. 执行同步代码(从上到下依次执行)
   ↓
2. 清空微任务队列(执行所有微任务,直到队列为空)
   ↓
3. 渲染更新(根据需要执行 requestAnimationFrame,进行样式计算、布局、绘制)
   ↓
4. 执行一个宏任务(从宏任务队列取出一个任务执行)
   ↓
5. 回到步骤 2,继续下一轮循环
```

### 5.2 任务优先级总结

```
同步代码(立即) > 微任务(Promise) > 渲染(rAF) > 宏任务(setTimeout) > 空闲任务(rIC)
```

### 5.3 关键特点

- **单线程执行**: 保证代码按顺序执行,避免多线程竞争
- **非阻塞**: 通过异步回调,长时间操作不阻塞主线程
- **微任务优先**: 每轮循环清空所有微任务后才执行下一个宏任务
- **渲染时机**: 浏览器在适当时机(通常是宏任务之间)进行页面渲染

---

## 六、常见面试题解析

### Q1: 阐述 JS 的事件循环

**参考答案:**

事件循环又叫消息循环,是浏览器渲染主线程的工作方式。

在 Chrome 源码中,它开启一个不会结束的 for 循环,每次循环从消息队列中取出第一个任务执行,其他线程只需在合适时机将任务加入队列末尾。

根据 W3C 规范,每个任务有不同类型,同类型任务必须在同一队列,不同任务可以属于不同队列。不同任务队列有不同优先级,浏览器自行决定取哪个队列的任务。但浏览器必须有一个微队列,微队列任务一定具有最高优先级,必须优先调度执行。

### Q2: 如何理解 JS 的异步?

**参考答案:**

JS 是单线程语言,运行在浏览器渲染主线程中。为避免多线程同时操作 DOM 产生冲突,浏览器将 JS 设计为单线程。

渲染主线程承担着渲染页面、执行 JS 等诸多工作。如果使用同步方式,极易导致主线程阻塞,消息队列中的任务无法执行,造成页面卡死。

因此浏览器采用异步机制:当遇到计时器、网络请求、事件监听等任务时,主线程将任务交给其他线程处理,自身立即结束任务执行,转而执行后续代码。其他线程完成后,将回调函数包装成任务加入消息队列末尾,等待主线程调度执行。

这种异步模式下,浏览器永不阻塞,最大限度保证了单线程的流畅运行。

### Q3: JS 中的计时器能做到精确计时吗?为什么?

**参考答案:**

不能精确计时,原因有:

1. **硬件限制**: 计算机硬件没有原子钟,无法做到绝对精确
2. **操作系统偏差**: OS 的计时函数本身就有少量偏差,JS 计时器调用 OS 函数,携带了这些偏差
3. **浏览器限制**: 按 W3C 标准,计时器嵌套层级超过 5 层时,会有 4ms 的最少时间限制
4. **事件循环影响**: 计时器回调函数只能在主线程空闲时运行,如果主线程繁忙,回调执行会延迟

---

## 总结

**事件循环是 JavaScript 单线程实现异步编程的核心机制**。它通过不断循环检查和执行任务队列中的任务,协调同步代码、异步回调和页面渲染的执行顺序。

理解事件循环是掌握 JavaScript 异步编程、性能优化和避免主线程阻塞的关键基础。
